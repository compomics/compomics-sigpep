package com.compomics.sigpep.playground;

import org.apache.log4j.Logger;
import com.compomics.sigpep.*;
import com.compomics.sigpep.analysis.SignatureTransitionFinder;
import com.compomics.sigpep.analysis.SignatureTransitionFinderType;
import com.compomics.sigpep.model.*;
import com.compomics.sigpep.report.SignatureTransitionCollectionMassMatrix;
import com.compomics.sigpep.util.DelimitedTableReader;
import com.compomics.sigpep.util.SigPepUtil;

import java.io.*;
import java.util.*;

/**
 * @TODO: JavaDoc missing.
 *
 * Created by IntelliJ IDEA.<br/>
 * User: mmueller<br/>
 * Date: 07-Aug-2008<br/>
 * Time: 16:51:47<br/>
 */
public class WatersCollaboration {

    private static Logger logger = Logger.getLogger(WatersCollaboration.class);

    /**
     * @TODO: JavaDoc missing.
     * 
     * @param args
     */
    public static void main(String[] args) {

//        String targetInputFile = "/home/mmueller/data/sigpep/collab_waters/heart_and_lysosomal_ensembl_gene_ids.txt";
//        String observedChargeStatesInputFile = "/home/mmueller/data/sigpep/collab_waters/michael_charge_details.tab";
//        String outputDir = "/home/mmueller/data/sigpep/collab_waters/transitions";

        /////////////
        //input files
        /////////////

        //identifiers of targeted genes
        String targetInputFile = args[0];

        //pairs of m/z and charge state
        String observedChargeStatesInputFile = args[1];

        //directory to write the results to
        String outputDir = args[2];

        ////////////////////
        //search paratmeters
        ////////////////////

        //the protease
        String proteaseShortName = "tryp";

        //the modifications
        String[] modifications = {"metox", "cyscarbamidmeth"};

        //target product ions to consider
        Set<ProductIonType> targetProductIonTypes = new HashSet<ProductIonType>();
        targetProductIonTypes.add(ProductIonType.Y);

        //background product ions to consider
        Set<ProductIonType> backgroundProductIonTypes = new HashSet<ProductIonType>();
        backgroundProductIonTypes.add(ProductIonType.Y);
        backgroundProductIonTypes.add(ProductIonType.B);

        //product ion charge states allowed
        Set<Integer> productIonChargeStates = new HashSet<Integer>();
        productIonChargeStates.add(1);

        //the assumed mass accuracy
        double massAccuracy = 1.5;

        //the minimum and maximum number of peaks
        //of a signature transition
        int minimumCombinationSize = 1;
        int maximumCombinationSize = 10;

        //the type of search algorithm
        SignatureTransitionFinderType type = SignatureTransitionFinderType.MINIMAL;

        //the target species
        int taxonId = 9606;

        ////////////////////////
        //setupDatabase search
        ////////////////////////

        //read gene ids from file
        logger.info("reading gene ids from file " + targetInputFile);
        Set<String> geneAccessions = readIdentifiers(targetInputFile);
        //Set<String> geneAccessions = new HashSet<String>();
        logger.info(geneAccessions.size() + " gene ids in file");

        logger.info("reading observed charges states from " + observedChargeStatesInputFile);
        List<Map<Double, Integer>> observedChargeStates = readPeptideChargeStates(observedChargeStatesInputFile);
        logger.info(observedChargeStates.size() + " mass charge combinations in file");

        //get application
        logger.info("locating application");
        SigPepApplication app = ApplicationLocator.getInstance().getApplication();

        //get session factory
        SigPepSessionFactory sessionFactory = app.getSigPepSessionFactory();

        //get organism instance for organism
        Organism organism = sessionFactory.getOrganism(taxonId);
        logger.info("creating session for organism " + organism.getScientificName());

        //create session for organism
        SigPepSession session = sessionFactory.createSigPepSession(organism);

        //get query service
        SigPepQueryService service = session.createSigPepQueryService();

        //fetch protease protease instance
        Protease protease = service.getProteaseByShortName(proteaseShortName);

        logger.info("creating peptide generator for " + protease.getFullName());
        //create peptide generator for protease
        PeptideGenerator generator = session.createPeptideGenerator(protease);
        Set<Modification> ptms = ModificationFactory.createPostTranslationalModifications(modifications);
        generator.setPostTranslationalModifications(ptms);

        logger.info("generating background peptides");
        //get peptides generated by protease
        Set<Peptide> backgroundPeptides = generator.getPeptides();
        logger.info(backgroundPeptides.size() + " background peptides");

        logger.info("fetching signature peptides");
        Map<String, Set<Peptide>> gene2SignaturePeptides = generator.getPeptidesByGeneAccessionAndGeneLevelDegeneracy(geneAccessions, 1);
        logger.info("signature peptides found for " + gene2SignaturePeptides.size() + " of " + geneAccessions.size() + ".");

        logger.info("creating signature transition finder");
        //create signature transition finder
        SignatureTransitionFinder finder = session.createSignatureTransitionFinder(
                backgroundPeptides,
                targetProductIonTypes,
                backgroundProductIonTypes,
                observedChargeStates,
                productIonChargeStates,
                massAccuracy,
                minimumCombinationSize,
                maximumCombinationSize,
                type);

        for (String geneAccession : gene2SignaturePeptides.keySet()) {

            //get protein to find signature transitions for
            logger.info("processing " + geneAccession);
            Set<Peptide> signaturePeptides = gene2SignaturePeptides.get(geneAccession);

            logger.info(signaturePeptides.size() + " signature peptides found");
            int i = 1;

            for (Peptide peptide : signaturePeptides) {

                logger.info("searching signature transitions for " + peptide.getSequenceString() + " (" + i + "/" + signaturePeptides.size() + ")");

                List<SignatureTransition> st = finder.findSignatureTransitions(peptide);
                logger.info(st.size() + " signature transitions found");

                logger.info("writing results to " + outputDir);
                writeResult(outputDir, geneAccession, st);
                i++;
            }

            logger.info("");

        }
    }

    /**
     * @TODO: JavaDoc missing.
     * 
     * @param filename
     * @return
     */
    public static List<Map<Double, Integer>> readPeptideChargeStates(String filename) {

        List<Map<Double, Integer>> retVal = new ArrayList<Map<Double, Integer>>();
        try {
            DelimitedTableReader dtr = new DelimitedTableReader(new FileInputStream(filename), "\t");
            for (Iterator<String[]> rows = dtr.read(); rows.hasNext();) {

                String[] row = rows.next();

                Map<Double, Integer> combination = new HashMap<Double, Integer>();
                try {
                    double mz = new Double(row[2]);
                    int charge = new Integer(row[1]);
                    double mass = (mz * charge) - charge;
                    combination.put(mass, new Integer(row[1]));
                } catch (NumberFormatException e) {
                    System.out.println(e);
                }
                retVal.add(combination);
            }
        } catch (IOException e) {
            logger.error(e);
        }

        return retVal;
    }

    /**
     * @TODO: JavaDoc missing.
     *
     * @param filename
     * @return
     */
    private static Set<String> readIdentifiers(String filename) {

        Set<String> retVal = new TreeSet<String>();
        try {

            InputStream input = new FileInputStream(filename);

            DelimitedTableReader dtr = new DelimitedTableReader(input, "\t");
            for (Iterator<String[]> rows = dtr.read(); rows.hasNext();) {
                String[] row = rows.next();
                retVal.add(row[0]);
            }

            input.close();

        } catch (IOException e) {
            logger.error(e);
        }

        return retVal;
    }

    /**
     * @TODO: JavaDoc missing.
     *
     * @param directory
     * @param geneAccession
     * @param transitions
     */
    private static void writeResult(
            String directory,
            String geneAccession,
            Collection<SignatureTransition> transitions) {

        //create output directory if it doesn't exist
        String outputDirName = directory + "/" + geneAccession;
        File outputDir = new File(outputDirName);
        if (!outputDir.exists()) {
            outputDir.mkdir();
        }

        appendToTable(outputDirName, geneAccession, transitions);
        createTransitionPlotMatrix(outputDirName, geneAccession, transitions);
    }

    /**
     * @TODO: JavaDoc missing.
     * 
     * @param directory
     * @param geneAccession
     * @param transitions
     */
    private static void createTransitionPlotMatrix(
            String directory,
            String geneAccession,
            Collection<SignatureTransition> transitions) {

        if (transitions.size() > 0) {

            Peptide p = transitions.iterator().next().getPeptide();

            StringBuffer filename = new StringBuffer();
            filename.append(directory);
            filename.append("/");
            filename.append(p.getSequenceString());
            filename.append(".tsv");

            try {

                OutputStream os = new FileOutputStream(filename.toString());

                SignatureTransitionCollectionMassMatrix m = new SignatureTransitionCollectionMassMatrix(transitions);
                m.write(os);
                os.close();

            } catch (IOException e) {
                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
            }
        }
    }

    /**
     * @TODO: JavaDoc missing.
     * 
     * @param directory
     * @param geneAccession
     * @param transitions
     */
    private static void appendToTable(
            String directory,
            String geneAccession,
            Collection<SignatureTransition> transitions) {

        try {

            //append transitions to table
            PrintWriter pw = new PrintWriter(new FileWriter(directory + "/" + geneAccession + ".tsv", true));

            for (SignatureTransition t : transitions) {

                Peptide p = t.getPeptide();
                StringBuffer line = new StringBuffer();
                int mostProbableCharge = -1;
                double chargeStateProbability = 0;
                double previousProbability = 0;
                Map<Integer, Double> allowedChargeStates = p.getPrecursorIon().getAllowedChargeStates();
                for (Integer charge : allowedChargeStates.keySet()) {

                    double probability = allowedChargeStates.get(charge);

                    if (probability > previousProbability) {
                        mostProbableCharge = charge;
                        chargeStateProbability = probability;
                    }

                    previousProbability = probability;
                }

                //gene accession
                line.append(geneAccession);
                line.append("\t");

                //peptide sequence
                line.append(p.getSequenceString());
                line.append("\t");

                //modified
                line.append(p.isModified());
                line.append("\t");

                //background count
                line.append(t.getBackgroundPeptides().size());
                line.append("\t");

                //neutral precursor mass
                line.append(SigPepUtil.round(p.getPrecursorIon().getNeutralMassPeptide(), 4));
                line.append("\t");

                //z
                line.append(mostProbableCharge);
                line.append("\t");

                //z probability
                line.append(SigPepUtil.round(chargeStateProbability, 4));
                line.append("\t");

                //precursor m/z
                line.append(SigPepUtil.round(p.getPrecursorIon().getMassOverCharge(mostProbableCharge), 4));
                line.append("\t");

                //product ion names
                int i = 0;
                for (ProductIon pi : t.getProductIons()) {
                    i++;
                    line.append(pi.getType()).append(pi.getSequenceLength());
                    if (i != t.getProductIons().size()) {
                        line.append(",");
                    }
                }
                line.append("\t");

                //product ion m/z
                i = 0;
                for (ProductIon pi : t.getProductIons()) {
                    i++;
                    line.append(SigPepUtil.round(pi.getMassOverCharge(1), 4));
                    if (i != t.getProductIons().size()) {
                        line.append(",");
                    }
                }
                line.append("\t");

                //combination score
                line.append(SigPepUtil.round(t.getExclusionScore(), 2));

                pw.println(line);
            }

            pw.close();

        } catch (IOException e) {
            logger.error(e);
        }
    }
}
